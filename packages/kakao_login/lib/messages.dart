// Autogenerated from Pigeon (v2.0.1), do not edit directly.
// See also: https://pub.dev/packages/pigeon
// ignore_for_file: public_member_api_docs, non_constant_identifier_names, avoid_as, unused_import, unnecessary_parenthesis, prefer_null_aware_operators, omit_local_variable_types, unused_shown_name
// @dart = 2.12
import 'dart:async';
import 'dart:typed_data' show Uint8List, Int32List, Int64List, Float64List;

import 'package:flutter/foundation.dart' show WriteBuffer, ReadBuffer;
import 'package:flutter/services.dart';

enum Prompt {
  login,
}

enum ApiErrorCause {
  InternalError,
  IllegalParams,
  UnsupportedApi,
  BlockedAction,
  PermissionDenied,
  DeprecatedApi,
  ApiLimitExceeded,
  NotRegisteredUser,
  AlreadyRegisteredUser,
  AccountDoesNotExist,
  PropertyKeyDoesNotExist,
}

enum AgeRange {
  age_0_9,
  age_10_14,
  age_15_19,
  age_20_29,
  age_30_39,
  age_40_49,
  age_50_59,
  age_60_69,
  age_70_79,
  age_80_89,
  age_90_above,
  unknown,
}

enum BirthdayType {
  solar,
  lunar,
  unknown,
}

enum Gender {
  female,
  male,
  unknown,
}

class OAuthToken {
  OAuthToken({
    required this.accessToken,
    this.accessTokenExpiresAt,
    this.expiresIn,
    required this.refreshToken,
    this.refreshTokenExpiresAt,
    this.refreshTokenExpiresIn,
    this.scopes,
  });

  String accessToken;
  int? accessTokenExpiresAt;
  int? expiresIn;
  String refreshToken;
  int? refreshTokenExpiresAt;
  int? refreshTokenExpiresIn;
  List<String?>? scopes;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['accessToken'] = accessToken;
    pigeonMap['accessTokenExpiresAt'] = accessTokenExpiresAt;
    pigeonMap['expiresIn'] = expiresIn;
    pigeonMap['refreshToken'] = refreshToken;
    pigeonMap['refreshTokenExpiresAt'] = refreshTokenExpiresAt;
    pigeonMap['refreshTokenExpiresIn'] = refreshTokenExpiresIn;
    pigeonMap['scopes'] = scopes;
    return pigeonMap;
  }

  static OAuthToken decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return OAuthToken(
      accessToken: pigeonMap['accessToken']! as String,
      accessTokenExpiresAt: pigeonMap['accessTokenExpiresAt'] as int?,
      expiresIn: pigeonMap['expiresIn'] as int?,
      refreshToken: pigeonMap['refreshToken']! as String,
      refreshTokenExpiresAt: pigeonMap['refreshTokenExpiresAt'] as int?,
      refreshTokenExpiresIn: pigeonMap['refreshTokenExpiresIn'] as int?,
      scopes: (pigeonMap['scopes'] as List<Object?>?)?.cast<String?>(),
    );
  }
}

class Profile {
  Profile({
    this.nickname,
    this.profileImageUrl,
    this.thumbnailImageUrl,
  });

  String? nickname;
  String? profileImageUrl;
  String? thumbnailImageUrl;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['nickname'] = nickname;
    pigeonMap['profileImageUrl'] = profileImageUrl;
    pigeonMap['thumbnailImageUrl'] = thumbnailImageUrl;
    return pigeonMap;
  }

  static Profile decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return Profile(
      nickname: pigeonMap['nickname'] as String?,
      profileImageUrl: pigeonMap['profileImageUrl'] as String?,
      thumbnailImageUrl: pigeonMap['thumbnailImageUrl'] as String?,
    );
  }
}

class Account {
  Account({
    this.profileImageNeedsAgreement,
    this.profileNeedsAgreement,
    this.profileNicknameNeedsAgreement,
    this.profile,
    this.isEmailVerified,
    this.isEmailValid,
    this.emailNeedsAgreement,
    this.email,
    this.isKakaotalkUser,
    this.phoneNumberNeedsAgreement,
    this.phoneNumber,
    this.ageRangeNeedsAgreement,
    this.ageRange,
    this.birthdayNeedsAgreement,
    this.birthday,
    this.birthyearNeedsAgreement,
    this.birthdayType,
    this.birthyear,
    this.genderNeedsAgreement,
    this.gender,
    this.ciNeedsAgreement,
    this.ci,
    this.ciAuthenticatedAt,
    this.legalNameNeedsAgreement,
    this.legalName,
    this.legalGenderNeedsAgreement,
    this.legalGender,
    this.legalBirthDate,
    this.isKorean,
    this.isKoreanNeedsAgreement,
    this.name,
    this.nameNeedsAgreement,
  });

  bool? profileImageNeedsAgreement;
  bool? profileNeedsAgreement;
  bool? profileNicknameNeedsAgreement;
  Profile? profile;
  bool? isEmailVerified;
  bool? isEmailValid;
  bool? emailNeedsAgreement;
  String? email;
  bool? isKakaotalkUser;
  bool? phoneNumberNeedsAgreement;
  String? phoneNumber;
  bool? ageRangeNeedsAgreement;
  AgeRange? ageRange;
  bool? birthdayNeedsAgreement;
  String? birthday;
  bool? birthyearNeedsAgreement;
  BirthdayType? birthdayType;
  String? birthyear;
  bool? genderNeedsAgreement;
  Gender? gender;
  bool? ciNeedsAgreement;
  String? ci;
  int? ciAuthenticatedAt;
  bool? legalNameNeedsAgreement;
  String? legalName;
  bool? legalGenderNeedsAgreement;
  Gender? legalGender;
  String? legalBirthDate;
  bool? isKorean;
  bool? isKoreanNeedsAgreement;
  String? name;
  bool? nameNeedsAgreement;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['profileImageNeedsAgreement'] = profileImageNeedsAgreement;
    pigeonMap['profileNeedsAgreement'] = profileNeedsAgreement;
    pigeonMap['profileNicknameNeedsAgreement'] = profileNicknameNeedsAgreement;
    pigeonMap['profile'] = profile == null ? null : profile!.encode();
    pigeonMap['isEmailVerified'] = isEmailVerified;
    pigeonMap['isEmailValid'] = isEmailValid;
    pigeonMap['emailNeedsAgreement'] = emailNeedsAgreement;
    pigeonMap['email'] = email;
    pigeonMap['isKakaotalkUser'] = isKakaotalkUser;
    pigeonMap['phoneNumberNeedsAgreement'] = phoneNumberNeedsAgreement;
    pigeonMap['phoneNumber'] = phoneNumber;
    pigeonMap['ageRangeNeedsAgreement'] = ageRangeNeedsAgreement;
    pigeonMap['ageRange'] = ageRange == null ? null : ageRange!.index;
    pigeonMap['birthdayNeedsAgreement'] = birthdayNeedsAgreement;
    pigeonMap['birthday'] = birthday;
    pigeonMap['birthyearNeedsAgreement'] = birthyearNeedsAgreement;
    pigeonMap['birthdayType'] = birthdayType == null ? null : birthdayType!.index;
    pigeonMap['birthyear'] = birthyear;
    pigeonMap['genderNeedsAgreement'] = genderNeedsAgreement;
    pigeonMap['gender'] = gender == null ? null : gender!.index;
    pigeonMap['ciNeedsAgreement'] = ciNeedsAgreement;
    pigeonMap['ci'] = ci;
    pigeonMap['ciAuthenticatedAt'] = ciAuthenticatedAt;
    pigeonMap['legalNameNeedsAgreement'] = legalNameNeedsAgreement;
    pigeonMap['legalName'] = legalName;
    pigeonMap['legalGenderNeedsAgreement'] = legalGenderNeedsAgreement;
    pigeonMap['legalGender'] = legalGender == null ? null : legalGender!.index;
    pigeonMap['legalBirthDate'] = legalBirthDate;
    pigeonMap['isKorean'] = isKorean;
    pigeonMap['isKoreanNeedsAgreement'] = isKoreanNeedsAgreement;
    pigeonMap['name'] = name;
    pigeonMap['nameNeedsAgreement'] = nameNeedsAgreement;
    return pigeonMap;
  }

  static Account decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return Account(
      profileImageNeedsAgreement: pigeonMap['profileImageNeedsAgreement'] as bool?,
      profileNeedsAgreement: pigeonMap['profileNeedsAgreement'] as bool?,
      profileNicknameNeedsAgreement: pigeonMap['profileNicknameNeedsAgreement'] as bool?,
      profile: pigeonMap['profile'] != null
          ? Profile.decode(pigeonMap['profile']!)
          : null,
      isEmailVerified: pigeonMap['isEmailVerified'] as bool?,
      isEmailValid: pigeonMap['isEmailValid'] as bool?,
      emailNeedsAgreement: pigeonMap['emailNeedsAgreement'] as bool?,
      email: pigeonMap['email'] as String?,
      isKakaotalkUser: pigeonMap['isKakaotalkUser'] as bool?,
      phoneNumberNeedsAgreement: pigeonMap['phoneNumberNeedsAgreement'] as bool?,
      phoneNumber: pigeonMap['phoneNumber'] as String?,
      ageRangeNeedsAgreement: pigeonMap['ageRangeNeedsAgreement'] as bool?,
      ageRange: pigeonMap['ageRange'] != null
          ? AgeRange.values[pigeonMap['ageRange']! as int]
          : null,
      birthdayNeedsAgreement: pigeonMap['birthdayNeedsAgreement'] as bool?,
      birthday: pigeonMap['birthday'] as String?,
      birthyearNeedsAgreement: pigeonMap['birthyearNeedsAgreement'] as bool?,
      birthdayType: pigeonMap['birthdayType'] != null
          ? BirthdayType.values[pigeonMap['birthdayType']! as int]
          : null,
      birthyear: pigeonMap['birthyear'] as String?,
      genderNeedsAgreement: pigeonMap['genderNeedsAgreement'] as bool?,
      gender: pigeonMap['gender'] != null
          ? Gender.values[pigeonMap['gender']! as int]
          : null,
      ciNeedsAgreement: pigeonMap['ciNeedsAgreement'] as bool?,
      ci: pigeonMap['ci'] as String?,
      ciAuthenticatedAt: pigeonMap['ciAuthenticatedAt'] as int?,
      legalNameNeedsAgreement: pigeonMap['legalNameNeedsAgreement'] as bool?,
      legalName: pigeonMap['legalName'] as String?,
      legalGenderNeedsAgreement: pigeonMap['legalGenderNeedsAgreement'] as bool?,
      legalGender: pigeonMap['legalGender'] != null
          ? Gender.values[pigeonMap['legalGender']! as int]
          : null,
      legalBirthDate: pigeonMap['legalBirthDate'] as String?,
      isKorean: pigeonMap['isKorean'] as bool?,
      isKoreanNeedsAgreement: pigeonMap['isKoreanNeedsAgreement'] as bool?,
      name: pigeonMap['name'] as String?,
      nameNeedsAgreement: pigeonMap['nameNeedsAgreement'] as bool?,
    );
  }
}

class User {
  User({
    this.id,
    this.properties,
    this.kakaoAccount,
    this.groupUserToken,
    this.connectedAt,
    this.synchedAt,
  });

  int? id;
  Map<String?, String?>? properties;
  Account? kakaoAccount;
  String? groupUserToken;
  int? connectedAt;
  int? synchedAt;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['id'] = id;
    pigeonMap['properties'] = properties;
    pigeonMap['kakaoAccount'] = kakaoAccount == null ? null : kakaoAccount!.encode();
    pigeonMap['groupUserToken'] = groupUserToken;
    pigeonMap['connectedAt'] = connectedAt;
    pigeonMap['synchedAt'] = synchedAt;
    return pigeonMap;
  }

  static User decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return User(
      id: pigeonMap['id'] as int?,
      properties: (pigeonMap['properties'] as Map<Object?, Object?>?)?.cast<String?, String?>(),
      kakaoAccount: pigeonMap['kakaoAccount'] != null
          ? Account.decode(pigeonMap['kakaoAccount']!)
          : null,
      groupUserToken: pigeonMap['groupUserToken'] as String?,
      connectedAt: pigeonMap['connectedAt'] as int?,
      synchedAt: pigeonMap['synchedAt'] as int?,
    );
  }
}

class AccessTokenInfo {
  AccessTokenInfo({
    this.id,
    required this.expiresIn,
    required this.appId,
  });

  int? id;
  int expiresIn;
  int appId;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['id'] = id;
    pigeonMap['expiresIn'] = expiresIn;
    pigeonMap['appId'] = appId;
    return pigeonMap;
  }

  static AccessTokenInfo decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return AccessTokenInfo(
      id: pigeonMap['id'] as int?,
      expiresIn: pigeonMap['expiresIn']! as int,
      appId: pigeonMap['appId']! as int,
    );
  }
}

class InitializeRequest {
  InitializeRequest({
    required this.appKey,
  });

  String appKey;

  Object encode() {
    final Map<Object?, Object?> pigeonMap = <Object?, Object?>{};
    pigeonMap['appKey'] = appKey;
    return pigeonMap;
  }

  static InitializeRequest decode(Object message) {
    final Map<Object?, Object?> pigeonMap = message as Map<Object?, Object?>;
    return InitializeRequest(
      appKey: pigeonMap['appKey']! as String,
    );
  }
}

class _KakaoLoginApiCodec extends StandardMessageCodec {
  const _KakaoLoginApiCodec();
  @override
  void writeValue(WriteBuffer buffer, Object? value) {
    if (value is AccessTokenInfo) {
      buffer.putUint8(128);
      writeValue(buffer, value.encode());
    } else 
    if (value is Account) {
      buffer.putUint8(129);
      writeValue(buffer, value.encode());
    } else 
    if (value is InitializeRequest) {
      buffer.putUint8(130);
      writeValue(buffer, value.encode());
    } else 
    if (value is OAuthToken) {
      buffer.putUint8(131);
      writeValue(buffer, value.encode());
    } else 
    if (value is OAuthToken) {
      buffer.putUint8(132);
      writeValue(buffer, value.encode());
    } else 
    if (value is Profile) {
      buffer.putUint8(133);
      writeValue(buffer, value.encode());
    } else 
    if (value is User) {
      buffer.putUint8(134);
      writeValue(buffer, value.encode());
    } else 
{
      super.writeValue(buffer, value);
    }
  }
  @override
  Object? readValueOfType(int type, ReadBuffer buffer) {
    switch (type) {
      case 128:       
        return AccessTokenInfo.decode(readValue(buffer)!);
      
      case 129:       
        return Account.decode(readValue(buffer)!);
      
      case 130:       
        return InitializeRequest.decode(readValue(buffer)!);
      
      case 131:       
        return OAuthToken.decode(readValue(buffer)!);
      
      case 132:       
        return OAuthToken.decode(readValue(buffer)!);
      
      case 133:       
        return Profile.decode(readValue(buffer)!);
      
      case 134:       
        return User.decode(readValue(buffer)!);
      
      default:      
        return super.readValueOfType(type, buffer);
      
    }
  }
}

class KakaoLoginApi {
  /// Constructor for [KakaoLoginApi].  The [binaryMessenger] named argument is
  /// available for dependency injection.  If it is left null, the default
  /// BinaryMessenger will be used which routes to the host platform.
  KakaoLoginApi({BinaryMessenger? binaryMessenger}) : _binaryMessenger = binaryMessenger;

  final BinaryMessenger? _binaryMessenger;

  static const MessageCodec<Object?> codec = _KakaoLoginApiCodec();

  Future<void> initialize(InitializeRequest arg_request) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KakaoLoginApi.initialize', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_request]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<OAuthToken?> currentToken() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KakaoLoginApi.currentToken', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as OAuthToken?);
    }
  }

  Future<String?> getHashKey() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KakaoLoginApi.getHashKey', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return (replyMap['result'] as String?);
    }
  }

  Future<AccessTokenInfo> accessTokenInfo() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KakaoLoginApi.accessTokenInfo', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as AccessTokenInfo?)!;
    }
  }

  Future<bool> isKakaoTalkLoginAvailable() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KakaoLoginApi.isKakaoTalkLoginAvailable', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as bool?)!;
    }
  }

  Future<void> logout() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KakaoLoginApi.logout', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> unlink() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KakaoLoginApi.unlink', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<OAuthToken> login() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KakaoLoginApi.login', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as OAuthToken?)!;
    }
  }

  Future<OAuthToken> logInWithKakaoTalk() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KakaoLoginApi.logInWithKakaoTalk', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as OAuthToken?)!;
    }
  }

  Future<OAuthToken> logInWithKakaoAccount() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KakaoLoginApi.logInWithKakaoAccount', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as OAuthToken?)!;
    }
  }

  Future<User> me() async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KakaoLoginApi.me', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(null) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else if (replyMap['result'] == null) {
      throw PlatformException(
        code: 'null-error',
        message: 'Host platform returned null value for non-null return value.',
      );
    } else {
      return (replyMap['result'] as User?)!;
    }
  }

  Future<void> signup(Map<String?, String?>? arg_properties) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KakaoLoginApi.signup', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_properties]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }

  Future<void> updateProfile(Map<String?, String?> arg_properties) async {
    final BasicMessageChannel<Object?> channel = BasicMessageChannel<Object?>(
        'dev.flutter.pigeon.KakaoLoginApi.updateProfile', codec, binaryMessenger: _binaryMessenger);
    final Map<Object?, Object?>? replyMap =
        await channel.send(<Object?>[arg_properties]) as Map<Object?, Object?>?;
    if (replyMap == null) {
      throw PlatformException(
        code: 'channel-error',
        message: 'Unable to establish connection on channel.',
      );
    } else if (replyMap['error'] != null) {
      final Map<Object?, Object?> error = (replyMap['error'] as Map<Object?, Object?>?)!;
      throw PlatformException(
        code: (error['code'] as String?)!,
        message: error['message'] as String?,
        details: error['details'],
      );
    } else {
      return;
    }
  }
}
